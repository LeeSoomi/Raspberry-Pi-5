# lidar_reader.py

import subprocess
import re
import time

cmd = ["./ultra_simple", "--channel", "--serial", "/dev/ttyUSB0", "115200"]

pattern = re.compile(r"theta:\s*([0-9.]+)\s+Dist:\s*([0-9.]+)")

p = subprocess.Popen(cmd, cwd="/home/soo/rplidar_sdk/output/Linux/Release",
                     stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                     text=True, bufsize=1)

def get_front_min_dist_mm(front_center=0, half_window=20):
    front_min = None
    start = time.time()
    while time.time() - start < 0.2:  # 0.2초만 읽고 최신값으로 판단
        line = p.stdout.readline()
        if not line:
            break
        m = pattern.search(line)
        if not m:
            continue
        theta = float(m.group(1))
        dist = float(m.group(2))
        # 각도 정규화: 0도 기준 전방. (환경에 따라 전방 기준이 다르면 보정 필요)
        # 전방 구간: [360-half_window ~ 360) U [0 ~ half_window]
        if theta >= 360 - half_window or theta <= half_window:
            if dist > 0:
                front_min = dist if front_min is None else min(front_min, dist)
    return front_min

try:
    while True:
        d = get_front_min_dist_mm()
        print("front_min_mm:", d)
        time.sleep(0.05)

except KeyboardInterrupt:
    pass

finally:
    p.terminate()





# main_line_lidar.py
import time
import subprocess
import re

# =========================
# 라이다 서브프로세스 리더 (1번에서 성공한 방식)
# =========================
LIDAR_CWD = "/home/soo/rplidar_sdk/output/Linux/Release"
LIDAR_CMD = ["./ultra_simple", "--channel", "--serial", "/dev/ttyUSB0", "115200"]
PATTERN = re.compile(r"theta:\s*([0-9.]+)\s+Dist:\s*([0-9.]+)")

p = subprocess.Popen(
    LIDAR_CMD,
    cwd=LIDAR_CWD,
    stdout=subprocess.PIPE,
    stderr=subprocess.STDOUT,
    text=True,
    bufsize=1
)

def get_front_min_dist_mm(half_window=20, read_window_s=0.15):
    """
    전방 각도 구간(360-윈도우~360, 0~윈도우)에서 최소 거리(mm)를 반환.
    None이면 유효 데이터가 아직 없다는 뜻.
    """
    front_min = None
    t0 = time.time()

    while time.time() - t0 < read_window_s:
        line = p.stdout.readline()
        if not line:
            break
        m = PATTERN.search(line)
        if not m:
            continue
        theta = float(m.group(1))
        dist = float(m.group(2))
        if dist <= 0:
            continue

        if theta >= 360 - half_window or theta <= half_window:
            front_min = dist if front_min is None else min(front_min, dist)

    return front_min


# =========================
# 모터 제어: 네 코드에 맞게 연결 (TODO 1)
# =========================
def motor_stop():
    # TODO 1-1: 네 모터 정지 함수로 교체
    pass

def motor_forward(speed=20):
    # TODO 1-2: 네 직진 함수로 교체
    pass

def motor_turn_left(speed=20):
    # TODO 1-3: 네 좌회전(제자리회전) 함수로 교체
    pass

def motor_turn_right(speed=20):
    # TODO 1-4: 네 우회전(제자리회전) 함수로 교체
    pass


# =========================
# 카메라 라인 인식: 네 코드에 맞게 연결 (TODO 2)
# =========================
def camera_get_line():
    """
    반환 예시
    line_found: True/False
    error: 라인 중심 오차 (왼쪽이면 음수, 오른쪽이면 양수 같은 방식)
    """
    # TODO 2: 네 라인추종 코드에서 매 프레임 얻는 값으로 교체
    # 예: (found, error) = get_line_error_from_camera()
    return False, 0.0

def line_follow_step(error):
    """
    error를 이용해 좌/우 바퀴 속도 조절 또는 좌/우 회전 명령을 내리는 1스텝.
    """
    # TODO 2-추가: 네 라인추종 제어 1회전 분량으로 교체
    pass


# =========================
# 장애물 회피 + 라인 복귀 상태머신 (2번)
# =========================
STOP_MM = 250     # 이 거리 이하면 장애물로 판단(시작값)
CLEAR_MM = 450    # 이 거리 이상이면 전방이 충분히 비었다고 판단(시작값)

TURN_SPEED = 20
FWD_SPEED = 20

AVOID_TURN_TIME = 0.55   # 회전 기본 시간(초)
AVOID_FWD_TIME  = 0.35   # 회피 후 전진 시간(초)
RETURN_SEARCH_TIME = 0.08  # 라인 탐색 루프 간격(초)

STATE_LINE_FOLLOW = "LINE_FOLLOW"
STATE_AVOID = "AVOID"
STATE_RETURN = "RETURN"

state = STATE_LINE_FOLLOW

try:
    while True:
        front_mm = get_front_min_dist_mm()

        if state == STATE_LINE_FOLLOW:
            line_found, error = camera_get_line()

            if front_mm is not None and front_mm < STOP_MM:
                motor_stop()
                time.sleep(0.12)
                state = STATE_AVOID
                continue

            if line_found:
                line_follow_step(error)
            else:
                # 라인이 순간적으로 끊기면 RETURN으로 넘겨서 다시 찾게 함
                motor_stop()
                time.sleep(0.05)
                state = STATE_RETURN

        elif state == STATE_AVOID:
            # 기본 회피 동작: 우회전(원하면 좌회전으로 바꿔도 됨)
            motor_turn_right(TURN_SPEED)
            time.sleep(AVOID_TURN_TIME)
            motor_stop()
            time.sleep(0.08)

            # 전방이 충분히 비었는지 재확인
            front_mm = get_front_min_dist_mm()
            if front_mm is None or front_mm < CLEAR_MM:
                # 아직 가까우면 회전을 한 번 더 반복
                continue

            # 안전거리 확보되면 짧게 전진
            motor_forward(FWD_SPEED)
            time.sleep(AVOID_FWD_TIME)
            motor_stop()
            time.sleep(0.08)

            state = STATE_RETURN

        elif state == STATE_RETURN:
            # 라인 탐색: 천천히 좌우로 찾는 방식 중 하나를 선택
            # 여기서는 우회전 탐색으로 시작
            line_found, error = camera_get_line()
            if line_found:
                state = STATE_LINE_FOLLOW
                continue

            motor_turn_right(TURN_SPEED)
            time.sleep(RETURN_SEARCH_TIME)
            motor_stop()
            time.sleep(0.02)

        else:
            motor_stop()
            state = STATE_LINE_FOLLOW

except KeyboardInterrupt:
    pass

finally:
    motor_stop()
    try:
        p.terminate()
    except Exception:
        pass
